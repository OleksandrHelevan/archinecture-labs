## Single Responsibility Principle (SRP)
Кожен із наведених класів має одну чітку причину для змін:
- `singleton.TicketRepository` — відповідає тільки за збереження, пошук і видалення квитків.
- `memento.Booking` — тільки зберігає стан бронювання і вміє його показати/зберегти/відновити.
- `memento.BookingHistory` — тільки керує історією станів через стек мементо.
- `state.TicketContext` — зберігає дані квитка і делегує дії поточному стану.
- `observer.BookingSystem` — тільки бронює/скасовує рейси та сповіщає спостерігачів.
- `template.TicketPurchaseTemplate` — визначає послідовність кроків купівлі квитка, не змішуючи її з реалізаціями конкретних кроків.

## Open/Closed Principle (OCP)
Код у проєкті відкритий для розширення через нові класи, але закритий для змін існуючих:
- `strategy.PaymentStrategy` / `PaymentType` — можна додати новий варіант оплати, не змінюючи клієнтський код, що працює з інтерфейсом.
- `state.TicketState` — нові стани квитка (наприклад, «Refuned») додаються як нові реалізації інтерфейсу, без змін у `TicketContext`.
- `template.TicketPurchaseTemplate` — нові сценарії купівлі (`KioskTicketPurchase` тощо) додаються як нові підкласи.
- `visitor.TicketVisitor` — нові дії над квитками (знижки, податки, звіти) реалізуються як нові відвідувачі без змін у класах квитків.

## Liskov Substitution Principle (LSP)
У всіх місцях, де використовується інтерфейс, можна підставити будь-яку його реалізацію без порушення логіки:
- Будь-який `PaymentType` використовується там, де очікується `PaymentStrategy`.
- Будь-який конкретний стан (`SelectingFlightState`, `PaymentPendingState`, `TicketConfirmedState`, `CancelledState`) може виступати як `TicketState` у `TicketContext`.
- Будь-який підписник (`PassengerNotifier`, `AdminDashboard`, `MobileApp`) може замінити інший, оскільки обробляється як `Observer`.
- Будь-який `TicketVisitor` (знижка чи податок) може бути підставлений там, де очікується інтерфейс `TicketVisitor`.

## Interface Segregation Principle (ISP)
Інтерфейси вузькі й не змушують реалізації підтримувати зайві методи:
- `PaymentStrategy` має лише один метод `calculateTotal`, необхідний для розрахунку вартості.
- `TicketState` містить тільки дії, релевантні життєвому циклу квитка.
- `Observer` і `Subject` мають мінімальні набори методів (`update`, `addObserver`, `notifyObservers`).
- `Mediator` та `Component` визначають тільки необхідні точки взаємодії (`notify`, `setMediator`).
- `visitor.TicketVisitor` і `TicketElement` містять тільки методи для відвідування та прийому відвідувача.

## Dependency Inversion Principle (DIP)
Вискорівневі модулі залежать від абстракцій, а не від конкретних реалізацій:
- `state.TicketContext` працює з абстракцією `TicketState`, а не з конкретним класом стану.
- Клієнтський код у `lab-10.Main` оперує `PaymentType`/`PaymentStrategy`, а не конкретними класами оплати.
- `observer.BookingSystem` залежить від інтерфейсу `Observer`, а не від конкретних типів підписників.
- Компоненти в пакеті `mediator` (`SearchForm`, `ResultList`, `PaymentButton`) залежать від інтерфейсу `Mediator`, а не конкретного `FlightMediator`.

## DRY / DIE (Don’t Repeat Yourself)
Загальна логіка винесена в одне місце й використовується повторно:
- `strategy.PaymentConstants` і `PaymentType` — єдине місце зберігання порогів і ставок комісій, що використовуються для різних типів оплати.
- `template.TicketPurchaseTemplate` — спільний шаблон послідовності кроків купівлі квитка, замість дублювання у веб/мобільній/офлайн-версіях.
- `singleton.TicketRepository` — єдина точка доступу до колекції квитків замість дублювання логіки зберігання у різних місцях.

## KISS (Keep It Simple, Stupid)
Більшість класів залишаються простими й легко зрозумілими:
- `memento.BookingHistory`, `memento.Booking` мають мінімум полів та методів, які напряму відповідають завданню збереження й відновлення стану.
- `observer.BookingSystem` інкапсулює просту модель «подія + сповіщення» без ускладнень.
- `singleton.TicketRepository` використовує звичайні колекції Java та прості методи доступу без зайвих шарів.

## YAGNI (You Ain’t Gonna Need It)
У проєкті немає зайвих універсальних механізмів, які не використовуються:
- Класи не містять «про запас» методів — наприклад, `Ticket`, `Route`, `City` мають тільки потрібні на даний момент поля та гетери/сетери.
- Інтерфейси (`PaymentStrategy`, `TicketState`, `Observer`, `Mediator`, `TicketVisitor`) не перевантажені непотрібними операціями.

## Release Equivalence Principle (REP)
Структура проєкту відображає логіку «релізних» одиниць:
- Окремі модулі (`first-lab`, `lab-4`, `lab-8`, `lab-9`, `lab-10`, `lab-11`) містять завершені приклади патернів та можуть розглядатися як незалежні навчальні релізи.

## Common Closure Principle (CCP)
Класи, які змінюються з однієї причини, згруповані разом:
- Пакет `strategy` об’єднує все, що може змінюватися при зміні політики розрахунку вартості (`PaymentStrategy`, `PaymentType`, `PaymentConstants`).
- Пакет `state` містить усі стани квитка й контекст, які змінюються разом при зміні бізнес-логіки життєвого циклу.
- Пакет `observer` об’єднує суб’єкт та підписників, які змінюються разом при зміні моделі сповіщень.

## Common Reuse Principle (CRP)
Класи згруповано так, щоб використовувались разом:
- Пакет `memento` (`Booking`, `BookingMemento`, `BookingHistory`) повторно використовується як один цілісний блок для задач з історією станів.
- Пакет `adapter` (`OnlineTicketOffice`, адаптери та системи посадкових талонів) використовується спільно при інтеграції із зовнішніми форматами.
- Пакет `visitor` (квитки та відвідувачі) створений як єдиний блок повторного використання для різних операцій над квитками.

## Acyclic Dependencies Principle (ADP)
Залежності між модулями не утворюють циклів:
- Окремі лабораторні модулі (`first-lab`, `lab-4`, `lab-8`, `lab-9`, `lab-10`, `lab-11`) не імпортують один одного, а всередині модулів залежності між пакетами побудовані ієрархічно (наприклад, `state.impl` залежить від `state`, але не навпаки).

## Stable Dependencies Principle (SDP)
Менш стабільний код залежить від більш стабільного:
- Конкретні реалізації станів, стратегій, спостерігачів і відвідувачів залежать від стабільних інтерфейсів (`TicketState`, `PaymentStrategy`, `Observer`, `TicketVisitor`), а не навпаки.

## Stable Abstractions Principle (SAP)
Стабільні пакети містять здебільшого абстракції:
- Пакети з інтерфейсами (`strategy`, `state`, `observer`, `mediator`, `visitor`) є відносно стабільними й містять ключові абстракції, тоді як конкретні реалізації розміщені в підпакетах (`impl`, `ticket`), що частіше змінюються.

## Бритва Оккама
У реалізації віддається перевага найпростішому рішенню, яке задовольняє вимоги:
- Для демонстрації патернів використано мінімальну кількість класів і полів — наприклад, `Booking`, `TicketContext`, `TicketRepository` не мають зайвої інфраструктури, а містять тільки те, що потрібно для показу відповідного патерну/принципу.

