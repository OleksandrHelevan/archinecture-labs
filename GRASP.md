## Information Expert (Інформаційний експерт)
У проєкті роль експертів з даних виконують класи, які містять усю необхідну інформацію та операції над нею:
- `common.Ticket`, `common.Route`, `common.City` — зберігають атрибути квитка та маршруту, на основі яких виконуються всі дії (пошук, бронювання, виведення інформації).
- `singleton.TicketRepository` — знає все про колекцію квитків (додавання, пошук, видалення), тому саме він відповідає за ці операції, а не зовнішні об’єкти.
- `memento.Booking` — містить усі дані про бронювання та сам зберігає/відновлює свій стан через `BookingMemento`.

## Creator (Творець)
Створення об’єктів доручено тим класам, які тісно з ними пов’язані:
- `abstract_factory.impl.TicketFactoryImpl` — створює квитки, оскільки працює безпосередньо з параметрами маршруту, ціни та валюти.
- `factory.impl.PaymentFactoryImpl` — створює конкретні реалізації оплати (`CreditCardPayment`, `PayPalPayment`, тощо) на основі `PaymentType`.
- `prototype.impl.GroupTicketService` — створює копії `GroupTicket`, тому що саме він організовує групові бронювання.
- `memento.BookingHistory` — створює та зберігає `BookingMemento`, оскільки керує історією змін бронювання.

## Controller (Контролер)
Керування сценаріями роботи та координація об’єктів зосереджені в точках входу:
- `AirportApp` (first-lab) — координує створення міст, маршрутів, квитків, запуск потоків та виклик фабрик/сервісів.
- `lab-9.Main`, `lab-10.Main`, `lab-11.Main` — відповідають за послідовність демонстраційних сценаріїв (створення контекстів, виклик методів станів, стратегій, шаблонів та відвідувачів).
- `adapter.OnlineTicketOffice` — виступає локальним контролером видачі посадкового талона, координуючи роботу з адаптерами.

## Low Coupling (Низька зв’язність)
Низька зв’язність досягається через використання інтерфейсів та шаблонів, які відокремлюють клієнтів від конкретних реалізацій:
- `strategy.PaymentStrategy` і `PaymentType` — клієнти працюють з інтерфейсом, не знаючи про конкретні класи оплати.
- `state.TicketState` та реалізації станів — `TicketContext` залежить лише від абстракції стану.
- `observer.Subject` / `Observer` — відправник не знає деталей підписників.
- `mediator.Mediator` / `FlightMediator` — компоненти (`SearchForm`, `ResultList`, `PaymentButton`) не залежать безпосередньо один від одного, а спілкуються через посередника.
- `visitor.TicketVisitor` / `TicketElement` — квитки та відвідувачі зв’язані через інтерфейси.

## High Cohesion (Висока когезія)
Кожен клас зосереджений на одній чіткій ролі:
- `singleton.TicketRepository` — тільки збереження/пошук/видалення квитків.
- `memento.BookingHistory` — тільки керування історією станів бронювання.
- `state.TicketContext` — тільки зберігання контексту квитка та делегування дій станам.
- `observer.BookingSystem` — тільки бронювання/скасування та сповіщення спостерігачів.
- `mediator.FlightMediator` — тільки координація взаємодії між формою пошуку, списком результатів і кнопкою оплати.

## Polymorphism (Поліморфізм)
Змінна поведінка реалізована через інтерфейси та успадкування:
- `state.TicketState` з реалізаціями (`SelectingFlightState`, `PaymentPendingState`, `TicketConfirmedState`, `CancelledState`) — різні стани по-різному реагують на однакові виклики (`selectFlight`, `makePayment`, тощо).
- `strategy.PaymentStrategy` і різні стратегії розрахунку вартості — поведінка оплати змінюється поліморфно.
- `template.TicketPurchaseTemplate` з підкласами (`WebTicketPurchase`, `MobileTicketPurchase`, `OfflineTicketPurchase`) — однаковий шаблон кроків, але відмінна реалізація окремих етапів.
- `visitor.TicketVisitor` і реалізації (`DiscountVisitor`, `TaxVisitor`) — різні відвідувачі по-різному обробляють ті самі типи квитків.
- `observer.Observer` з реалізаціями (`PassengerNotifier`, `AdminDashboard`, `MobileApp`) — кожний підписник по-своєму обробляє сповіщення.

## Pure Fabrication (Штучний об’єкт)
Деякі класи не є природними сутностями предметної області, але введені для кращої структури:
- `singleton.TicketRepository` — окремий репозиторій для роботи з колекцією квитків, щоб не перевантажувати доменні класи.
- `object_pool.RacePool` — окремий менеджер конкурентного доступу до квитків.
- `mediator.FlightMediator` — штучний посередник між UI-компонентами пошуку/результатів/оплати.
- `adapter.PdfPassAdapter`, `adapter.TxtPassAdapter` — окремі адаптери для інтеграції з різними системами посадкових талонів.

## Indirection (Перенаправлення)
Посередники вставлені між клієнтами й реальними виконавцями:
- `mediator.Mediator` / `FlightMediator` — перенаправляє події між `SearchForm`, `ResultList` та `PaymentButton`, усуваючи прямі залежності.
- `observer.Subject` / `Observer` — сповіщення йдуть через інтерфейс, а не напряму між конкретними класами.
- `adapter.PdfPassAdapter`, `adapter.TxtPassAdapter` та `OnlineTicketOffice` — відокремлюють онлайн-офіс від конкретних реалізацій генераторів посадкових талонів.
- `factory.impl.PaymentFactoryImpl` — додатковий рівень між клієнтом і конкретними класами оплати.

## Protected Variations (Стійкість до змін)
Місця потенційних змін захищені стабільними інтерфейсами:
- `strategy.PaymentStrategy` / `PaymentType` — можна додати новий тип оплати без змін у клієнтському коді.
- `state.TicketState` — нові стани квитка можна додавати, не змінюючи логіку `TicketContext`.
- `template.TicketPurchaseTemplate` — нові способи купівлі квитків додаються через нові підкласи, не змінюючи базовий шаблон.
- `visitor.TicketVisitor` / `TicketElement` — нові операції над квитками додаються через нових відвідувачів, не змінюючи класи квитків.
- `observer.Observer` / `Subject` — можна додавати нових підписників, не змінюючи `BookingSystem`.
